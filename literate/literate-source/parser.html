<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Parser</title>
<script>
!function(){var q=null;window.PR_SHOULD_USE_CONTINUATION=!0;
(function(){function R(a){function d(e){var b=e.charCodeAt(0);if(b!==92)return b;var a=e.charAt(1);return(b=r[a])?b:"0"<=a&&a<="7"?parseInt(e.substring(1),8):a==="u"||a==="x"?parseInt(e.substring(2),16):e.charCodeAt(1)}function g(e){if(e<32)return(e<16?"\\x0":"\\x")+e.toString(16);e=String.fromCharCode(e);return e==="\\"||e==="-"||e==="]"||e==="^"?"\\"+e:e}function b(e){var b=e.substring(1,e.length-1).match(/\\u[\dA-Fa-f]{4}|\\x[\dA-Fa-f]{2}|\\[0-3][0-7]{0,2}|\\[0-7]{1,2}|\\[\S\s]|[^\\]/g),e=[],a=
b[0]==="^",c=["["];a&&c.push("^");for(var a=a?1:0,f=b.length;a<f;++a){var h=b[a];if(/\\[bdsw]/i.test(h))c.push(h);else{var h=d(h),l;a+2<f&&"-"===b[a+1]?(l=d(b[a+2]),a+=2):l=h;e.push([h,l]);l<65||h>122||(l<65||h>90||e.push([Math.max(65,h)|32,Math.min(l,90)|32]),l<97||h>122||e.push([Math.max(97,h)&-33,Math.min(l,122)&-33]))}}e.sort(function(e,a){return e[0]-a[0]||a[1]-e[1]});b=[];f=[];for(a=0;a<e.length;++a)h=e[a],h[0]<=f[1]+1?f[1]=Math.max(f[1],h[1]):b.push(f=h);for(a=0;a<b.length;++a)h=b[a],c.push(g(h[0])),
h[1]>h[0]&&(h[1]+1>h[0]&&c.push("-"),c.push(g(h[1])));c.push("]");return c.join("")}function s(e){for(var a=e.source.match(/\[(?:[^\\\] ]|\\[\S\s])*]|\\u[\dA-Fa-f]{4}|\\x[\dA-Fa-f]{2}|\\\d+|\\[^\dux]|\(\?[!:=]|[()^]|[^()[\\^]+/g),c=a.length,d=[],f=0,h=0;f<c;++f){var l=a[f];l==="("?++h:"\\"===l.charAt(0)&&(l=+l.substring(1))&&(l<=h?d[l]=-1:a[f]=g(l))}for(f=1;f<d.length;++f)-1===d[f]&&(d[f]=++x);for(h=f=0;f<c;++f)l=a[f],l==="("?(++h,d[h]||(a[f]="(?:")):"\\"===l.charAt(0)&&(l=+l.substring(1))&&l<=h&&
(a[f]="\\"+d[l]);for(f=0;f<c;++f)"^"===a[f]&&"^"!==a[f+1]&&(a[f]="");if(e.ignoreCase&&m)for(f=0;f<c;++f)l=a[f],e=l.charAt(0),l.length>=2&&e==="["?a[f]=b(l):e!=="\\"&&(a[f]=l.replace(/[A-Za-z]/g,function(a){a=a.charCodeAt(0);return"["+String.fromCharCode(a&-33,a|32)+"]"}));return a.join("")}for(var x=0,m=!1,j=!1,k=0,c=a.length;k<c;++k){var i=a[k];if(i.ignoreCase)j=!0;else if(/[a-z]/i.test(i.source.replace(/\\u[\da-f]{4}|\\x[\da-f]{2}|\\[^UXux]/gi,""))){m=!0;j=!1;break}}for(var r={b:8,t:9,n:10,v:11,
f:12,r:13},n=[],k=0,c=a.length;k<c;++k){i=a[k];if(i.global||i.multiline)throw Error(""+i);n.push("(?:"+s(i)+")")}return RegExp(n.join("|"),j?"gi":"g")}function S(a,d){function g(a){var c=a.nodeType;if(c==1){if(!b.test(a.className)){for(c=a.firstChild;c;c=c.nextSibling)g(c);c=a.nodeName.toLowerCase();if("br"===c||"li"===c)s[j]="\n",m[j<<1]=x++,m[j++<<1|1]=a}}else if(c==3||c==4)c=a.nodeValue,c.length&&(c=d?c.replace(/\r\n?/g,"\n"):c.replace(/[\t\n\r ]+/g," "),s[j]=c,m[j<<1]=x,x+=c.length,m[j++<<1|1]=
a)}var b=/(?:^|\s)nocode(?:\s|$)/,s=[],x=0,m=[],j=0;g(a);return{a:s.join("").replace(/\n$/,""),d:m}}function H(a,d,g,b){d&&(a={a:d,e:a},g(a),b.push.apply(b,a.g))}function T(a){for(var d=void 0,g=a.firstChild;g;g=g.nextSibling)var b=g.nodeType,d=b===1?d?a:g:b===3?U.test(g.nodeValue)?a:d:d;return d===a?void 0:d}function D(a,d){function g(a){for(var j=a.e,k=[j,"pln"],c=0,i=a.a.match(s)||[],r={},n=0,e=i.length;n<e;++n){var z=i[n],w=r[z],t=void 0,f;if(typeof w==="string")f=!1;else{var h=b[z.charAt(0)];
if(h)t=z.match(h[1]),w=h[0];else{for(f=0;f<x;++f)if(h=d[f],t=z.match(h[1])){w=h[0];break}t||(w="pln")}if((f=w.length>=5&&"lang-"===w.substring(0,5))&&!(t&&typeof t[1]==="string"))f=!1,w="src";f||(r[z]=w)}h=c;c+=z.length;if(f){f=t[1];var l=z.indexOf(f),B=l+f.length;t[2]&&(B=z.length-t[2].length,l=B-f.length);w=w.substring(5);H(j+h,z.substring(0,l),g,k);H(j+h+l,f,I(w,f),k);H(j+h+B,z.substring(B),g,k)}else k.push(j+h,w)}a.g=k}var b={},s;(function(){for(var g=a.concat(d),j=[],k={},c=0,i=g.length;c<i;++c){var r=
g[c],n=r[3];if(n)for(var e=n.length;--e>=0;)b[n.charAt(e)]=r;r=r[1];n=""+r;k.hasOwnProperty(n)||(j.push(r),k[n]=q)}j.push(/[\S\s]/);s=R(j)})();var x=d.length;return g}function v(a){var d=[],g=[];a.tripleQuotedStrings?d.push(["str",/^(?:'''(?:[^'\\]|\\[\S\s]|''?(?=[^']))*(?:'''|$)|"""(?:[^"\\]|\\[\S\s]|""?(?=[^"]))*(?:"""|$)|'(?:[^'\\]|\\[\S\s])*(?:'|$)|"(?:[^"\\]|\\[\S\s])*(?:"|$))/,q,"'\""]):a.multiLineStrings?d.push(["str",/^(?:'(?:[^'\\]|\\[\S\s])*(?:'|$)|"(?:[^"\\]|\\[\S\s])*(?:"|$)|`(?:[^\\`]|\\[\S\s])*(?:`|$))/,
q,"'\"`"]):d.push(["str",/^(?:'(?:[^\n\r'\\]|\\.)*(?:'|$)|"(?:[^\n\r"\\]|\\.)*(?:"|$))/,q,"\"'"]);a.verbatimStrings&&g.push(["str",/^@"(?:[^"]|"")*(?:"|$)/,q]);var b=a.hashComments;b&&(a.cStyleComments?(b>1?d.push(["com",/^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/,q,"#"]):d.push(["com",/^#(?:(?:define|e(?:l|nd)if|else|error|ifn?def|include|line|pragma|undef|warning)\b|[^\n\r]*)/,q,"#"]),g.push(["str",/^<(?:(?:(?:\.\.\/)*|\/?)(?:[\w-]+(?:\/[\w-]+)+)?[\w-]+\.h(?:h|pp|\+\+)?|[a-z]\w*)>/,q])):d.push(["com",
/^#[^\n\r]*/,q,"#"]));a.cStyleComments&&(g.push(["com",/^\/\/[^\n\r]*/,q]),g.push(["com",/^\/\*[\S\s]*?(?:\*\/|$)/,q]));if(b=a.regexLiterals){var s=(b=b>1?"":"\n\r")?".":"[\\S\\s]";g.push(["lang-regex",RegExp("^(?:^^\\.?|[+-]|[!=]=?=?|\\#|%=?|&&?=?|\\(|\\*=?|[+\\-]=|->|\\/=?|::?|<<?=?|>>?>?=?|,|;|\\?|@|\\[|~|{|\\^\\^?=?|\\|\\|?=?|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\\s*("+("/(?=[^/*"+b+"])(?:[^/\\x5B\\x5C"+b+"]|\\x5C"+s+"|\\x5B(?:[^\\x5C\\x5D"+b+"]|\\x5C"+
s+")*(?:\\x5D|$))+/")+")")])}(b=a.types)&&g.push(["typ",b]);b=(""+a.keywords).replace(/^ | $/g,"");b.length&&g.push(["kwd",RegExp("^(?:"+b.replace(/[\s,]+/g,"|")+")\\b"),q]);d.push(["pln",/^\s+/,q," \r\n\t\u00a0"]);b="^.[^\\s\\w.$@'\"`/\\\\]*";a.regexLiterals&&(b+="(?!s*/)");g.push(["lit",/^@[$_a-z][\w$@]*/i,q],["typ",/^(?:[@_]?[A-Z]+[a-z][\w$@]*|\w+_t\b)/,q],["pln",/^[$_a-z][\w$@]*/i,q],["lit",/^(?:0x[\da-f]+|(?:\d(?:_\d+)*\d*(?:\.\d*)?|\.\d\+)(?:e[+-]?\d+)?)[a-z]*/i,q,"0123456789"],["pln",/^\\[\S\s]?/,
q],["pun",RegExp(b),q]);return D(d,g)}function J(a,d,g){function b(a){var c=a.nodeType;if(c==1&&!x.test(a.className))if("br"===a.nodeName)s(a),a.parentNode&&a.parentNode.removeChild(a);else for(a=a.firstChild;a;a=a.nextSibling)b(a);else if((c==3||c==4)&&g){var d=a.nodeValue,i=d.match(m);if(i)c=d.substring(0,i.index),a.nodeValue=c,(d=d.substring(i.index+i[0].length))&&a.parentNode.insertBefore(j.createTextNode(d),a.nextSibling),s(a),c||a.parentNode.removeChild(a)}}function s(a){function b(a,c){var d=
c?a.cloneNode(!1):a,e=a.parentNode;if(e){var e=b(e,1),g=a.nextSibling;e.appendChild(d);for(var i=g;i;i=g)g=i.nextSibling,e.appendChild(i)}return d}for(;!a.nextSibling;)if(a=a.parentNode,!a)return;for(var a=b(a.nextSibling,0),d;(d=a.parentNode)&&d.nodeType===1;)a=d;c.push(a)}for(var x=/(?:^|\s)nocode(?:\s|$)/,m=/\r\n?|\n/,j=a.ownerDocument,k=j.createElement("li");a.firstChild;)k.appendChild(a.firstChild);for(var c=[k],i=0;i<c.length;++i)b(c[i]);d===(d|0)&&c[0].setAttribute("value",d);var r=j.createElement("ol");
r.className="linenums";for(var d=Math.max(0,d-1|0)||0,i=0,n=c.length;i<n;++i)k=c[i],k.className="L"+(i+d)%10,k.firstChild||k.appendChild(j.createTextNode("\u00a0")),r.appendChild(k);a.appendChild(r)}function p(a,d){for(var g=d.length;--g>=0;){var b=d[g];F.hasOwnProperty(b)?E.console&&console.warn("cannot override language handler %s",b):F[b]=a}}function I(a,d){if(!a||!F.hasOwnProperty(a))a=/^\s*</.test(d)?"default-markup":"default-code";return F[a]}function K(a){var d=a.h;try{var g=S(a.c,a.i),b=g.a;
a.a=b;a.d=g.d;a.e=0;I(d,b)(a);var s=/\bMSIE\s(\d+)/.exec(navigator.userAgent),s=s&&+s[1]<=8,d=/\n/g,x=a.a,m=x.length,g=0,j=a.d,k=j.length,b=0,c=a.g,i=c.length,r=0;c[i]=m;var n,e;for(e=n=0;e<i;)c[e]!==c[e+2]?(c[n++]=c[e++],c[n++]=c[e++]):e+=2;i=n;for(e=n=0;e<i;){for(var p=c[e],w=c[e+1],t=e+2;t+2<=i&&c[t+1]===w;)t+=2;c[n++]=p;c[n++]=w;e=t}c.length=n;var f=a.c,h;if(f)h=f.style.display,f.style.display="none";try{for(;b<k;){var l=j[b+2]||m,B=c[r+2]||m,t=Math.min(l,B),A=j[b+1],G;if(A.nodeType!==1&&(G=x.substring(g,
t))){s&&(G=G.replace(d,"\r"));A.nodeValue=G;var L=A.ownerDocument,o=L.createElement("span");o.className=c[r+1];var v=A.parentNode;v.replaceChild(o,A);o.appendChild(A);g<l&&(j[b+1]=A=L.createTextNode(x.substring(t,l)),v.insertBefore(A,o.nextSibling))}g=t;g>=l&&(b+=2);g>=B&&(r+=2)}}finally{if(f)f.style.display=h}}catch(u){E.console&&console.log(u&&u.stack||u)}}var E=window,y=["break,continue,do,else,for,if,return,while"],C=[[y,"auto,case,char,const,default,double,enum,extern,float,goto,inline,int,long,register,short,signed,sizeof,static,struct,switch,typedef,union,unsigned,void,volatile"],
"catch,class,delete,false,import,new,operator,private,protected,public,this,throw,true,try,typeof"],M=[C,"alignof,align_union,asm,axiom,bool,concept,concept_map,const_cast,constexpr,decltype,delegate,dynamic_cast,explicit,export,friend,generic,late_check,mutable,namespace,nullptr,property,reinterpret_cast,static_assert,static_cast,template,typeid,typename,using,virtual,where"],V=[C,"abstract,assert,boolean,byte,extends,final,finally,implements,import,instanceof,interface,null,native,package,strictfp,super,synchronized,throws,transient"],
N=[C,"abstract,as,base,bool,by,byte,checked,decimal,delegate,descending,dynamic,event,finally,fixed,foreach,from,group,implicit,in,interface,internal,into,is,let,lock,null,object,out,override,orderby,params,partial,readonly,ref,sbyte,sealed,stackalloc,string,select,uint,ulong,unchecked,unsafe,ushort,var,virtual,where"],C=[C,"debugger,eval,export,function,get,null,set,undefined,var,with,Infinity,NaN"],O=[y,"and,as,assert,class,def,del,elif,except,exec,finally,from,global,import,in,is,lambda,nonlocal,not,or,pass,print,raise,try,with,yield,False,True,None"],
P=[y,"alias,and,begin,case,class,def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,rescue,retry,self,super,then,true,undef,unless,until,when,yield,BEGIN,END"],W=[y,"as,assert,const,copy,drop,enum,extern,fail,false,fn,impl,let,log,loop,match,mod,move,mut,priv,pub,pure,ref,self,static,struct,true,trait,type,unsafe,use"],y=[y,"case,done,elif,esac,eval,fi,function,in,local,set,then,until"],Q=/^(DIR|FILE|vector|(de|priority_)?queue|list|stack|(const_)?iterator|(multi)?(set|map)|bitset|u?(int|float)\d*)\b/,
U=/\S/,X=v({keywords:[M,N,C,"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END",O,P,y],hashComments:!0,cStyleComments:!0,multiLineStrings:!0,regexLiterals:!0}),F={};p(X,["default-code"]);p(D([],[["pln",/^[^<?]+/],["dec",/^<!\w[^>]*(?:>|$)/],["com",/^<\!--[\S\s]*?(?:--\>|$)/],["lang-",/^<\?([\S\s]+?)(?:\?>|$)/],["lang-",/^<%([\S\s]+?)(?:%>|$)/],["pun",/^(?:<[%?]|[%?]>)/],["lang-",
/^<xmp\b[^>]*>([\S\s]+?)<\/xmp\b[^>]*>/i],["lang-js",/^<script\b[^>]*>([\S\s]*?)(<\/script\b[^>]*>)/i],["lang-css",/^<style\b[^>]*>([\S\s]*?)(<\/style\b[^>]*>)/i],["lang-in.tag",/^(<\/?[a-z][^<>]*>)/i] ]),["default-markup","htm","html","mxml","xhtml","xml","xsl"]);p(D([["pln",/^\s+/,q," \t\r\n"],["atv",/^(?:"[^"]*"?|'[^']*'?)/,q,"\"'"] ],[["tag",/^^<\/?[a-z](?:[\w-.:]*\w)?|\/?>$/i],["atn",/^(?!style[\s=]|on)[a-z](?:[\w:-]*\w)?/i],["lang-uq.val",/^=\s*([^\s"'>]*(?:[^\s"'/>]|\/(?=\s)))/],["pun",/^[/<->]+/],
["lang-js",/^on\w+\s*=\s*"([^"]+)"/i],["lang-js",/^on\w+\s*=\s*'([^']+)'/i],["lang-js",/^on\w+\s*=\s*([^\s"'>]+)/i],["lang-css",/^style\s*=\s*"([^"]+)"/i],["lang-css",/^style\s*=\s*'([^']+)'/i],["lang-css",/^style\s*=\s*([^\s"'>]+)/i] ]),["in.tag"]);p(D([],[["atv",/^[\S\s]+/] ]),["uq.val"]);p(v({keywords:M,hashComments:!0,cStyleComments:!0,types:Q}),["c","cc","cpp","cxx","cyc","m"]);p(v({keywords:"null,true,false"}),["json"]);p(v({keywords:N,hashComments:!0,cStyleComments:!0,verbatimStrings:!0,types:Q}),
["cs"]);p(v({keywords:V,cStyleComments:!0}),["java"]);p(v({keywords:y,hashComments:!0,multiLineStrings:!0}),["bash","bsh","csh","sh"]);p(v({keywords:O,hashComments:!0,multiLineStrings:!0,tripleQuotedStrings:!0}),["cv","py","python"]);p(v({keywords:"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END",hashComments:!0,multiLineStrings:!0,regexLiterals:2}),["perl","pl","pm"]);p(v({keywords:P,
hashComments:!0,multiLineStrings:!0,regexLiterals:!0}),["rb","ruby"]);p(v({keywords:C,cStyleComments:!0,regexLiterals:!0}),["javascript","js"]);p(v({keywords:"all,and,by,catch,class,else,extends,false,finally,for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,throw,true,try,unless,until,when,while,yes",hashComments:3,cStyleComments:!0,multilineStrings:!0,tripleQuotedStrings:!0,regexLiterals:!0}),["coffee"]);p(v({keywords:W,cStyleComments:!0,multilineStrings:!0}),["rc","rs","rust"]);
p(D([],[["str",/^[\S\s]+/] ]),["regex"]);var Y=E.PR={createSimpleLexer:D,registerLangHandler:p,sourceDecorator:v,PR_ATTRIB_NAME:"atn",PR_ATTRIB_VALUE:"atv",PR_COMMENT:"com",PR_DECLARATION:"dec",PR_KEYWORD:"kwd",PR_LITERAL:"lit",PR_NOCODE:"nocode",PR_PLAIN:"pln",PR_PUNCTUATION:"pun",PR_SOURCE:"src",PR_STRING:"str",PR_TAG:"tag",PR_TYPE:"typ",prettyPrintOne:E.prettyPrintOne=function(a,d,g){var b=document.createElement("div");b.innerHTML="<pre>"+a+"</pre>";b=b.firstChild;g&&J(b,g,!0);K({h:d,j:g,c:b,i:1});
return b.innerHTML},prettyPrint:E.prettyPrint=function(a,d){function g(){for(var b=E.PR_SHOULD_USE_CONTINUATION?c.now()+250:Infinity;i<p.length&&c.now()<b;i++){for(var d=p[i],j=h,k=d;k=k.previousSibling;){var m=k.nodeType,o=(m===7||m===8)&&k.nodeValue;if(o?!/^\??prettify\b/.test(o):m!==3||/\S/.test(k.nodeValue))break;if(o){j={};o.replace(/\b(\w+)=([\w%+\-.:]+)/g,function(a,b,c){j[b]=c});break}}k=d.className;if((j!==h||e.test(k))&&!v.test(k)){m=!1;for(o=d.parentNode;o;o=o.parentNode)if(f.test(o.tagName)&&
o.className&&e.test(o.className)){m=!0;break}if(!m){d.className+=" prettyprinted";m=j.lang;if(!m){var m=k.match(n),y;if(!m&&(y=T(d))&&t.test(y.tagName))m=y.className.match(n);m&&(m=m[1])}if(w.test(d.tagName))o=1;else var o=d.currentStyle,u=s.defaultView,o=(o=o?o.whiteSpace:u&&u.getComputedStyle?u.getComputedStyle(d,q).getPropertyValue("white-space"):0)&&"pre"===o.substring(0,3);u=j.linenums;if(!(u=u==="true"||+u))u=(u=k.match(/\blinenums\b(?::(\d+))?/))?u[1]&&u[1].length?+u[1]:!0:!1;u&&J(d,u,o);r=
{h:m,c:d,j:u,i:o};K(r)}}}i<p.length?setTimeout(g,250):"function"===typeof a&&a()}for(var b=d||document.body,s=b.ownerDocument||document,b=[b.getElementsByTagName("pre"),b.getElementsByTagName("code"),b.getElementsByTagName("xmp")],p=[],m=0;m<b.length;++m)for(var j=0,k=b[m].length;j<k;++j)p.push(b[m][j]);var b=q,c=Date;c.now||(c={now:function(){return+new Date}});var i=0,r,n=/\blang(?:uage)?-([\w.]+)(?!\S)/,e=/\bprettyprint\b/,v=/\bprettyprinted\b/,w=/pre|xmp/i,t=/^code$/i,f=/^(?:pre|code|xmp)$/i,
h={};g()}};typeof define==="function"&&define.amd&&define("google-code-prettify",[],function(){return Y})})();}()
</script>
<style>
.pln{color:#1b181b}.str{color:#918b3b}.kwd{color:#7b59c0}.com{color:#9e8f9e}.typ{color:#516aec}.lit{color:#a65926}.clo,.opn,.pun{color:#1b181b}.tag{color:#ca402b}.atn{color:#a65926}.atv{color:#159393}.dec{color:#a65926}.var{color:#ca402b}.fun{color:#516aec}pre.prettyprint{background:#f7f3f7;color:#ab9bab;font-family:Menlo,Consolas,"Bitstream Vera Sans Mono","DejaVu Sans Mono",Monaco,monospace;font-size:12px;line-height:1.5;border:1px solid #d8cad8;padding:10px}ol.linenums{margin-top:0;margin-bottom:0}
body{min-width:200px;max-width:850px;margin:0 auto;padding:30px;}.chapter-nav{font-size: 10pt;}a:link,a:visited{color:#00f}.codeblock_name,code,pre.prettyprint{font-family:Monaco,"Lucida Console",monospace}body{font-size:14pt}.codeblock_name,.math,.seealso,code{font-size:10pt}.codeblock{page-break-inside:avoid;padding-bottom:15px}.math{text-indent:0}pre.prettyprint{font-size:10pt;padding:10px;border-radius:10px;border:none;white-space:pre-wrap}.codeblock_name{margin-top:1.25em;display:block}a:link{text-decoration:none}a:link:not(.lit):hover{color:#00f;text-decoration:underline}a:link:active{color:red}h4{padding-right:1.25em}h4.noheading{margin-bottom:0}h1{text-align:center}code{padding:2px}pre{-moz-tab-size:4;-o-tab-size:4;tab-size:4}p:not(.notp){margin:0;text-indent:2em}.two-col{list-style-type:none}.two-col li:before{content:'-';padding:5px;margin-right:5px;color:orange;background-color:#fff;display:inline-block}@media print{body{font-size:10pt}pre.prettyprint{font-size:8pt}.seealso{font-size:9pt}.codeblock_name,.math,code{font-size:8pt}.math{text-indent:0}}
</style>
</head>
<body onload="prettyPrint()">
<section>
<h1>Parser</h1>
<a name="1:1"><div class="section"><h4>1. Introduction</h4></a>
<p>This is an implementation of a literate programming system in D.
The goal is to be able to create books that one can read on a website,
with chapters, subchapters, and sections, and additionally to be able
to compile the code from the book into a working program.
</p>
<p>Literate proogramming aims to make the source code of a program
understandable. The program can be structured in any way the
programmer likes, and the code should be explained.
</p>
<p>The source code for a literate program will somewhat resemble
CWEB, but differ in many key ways which simplify the source code
and make it easier to read. Literate will use @ signs for commands
and markdown to style the prose. 
</p>

</div>
<a name="1:2"><div class="section"><h4>2. Directory Structure</h4></a>
<p>A Literate program may be just a single file, but it should also be
possible to make a book out of it, with chapters and possibly multiple
programs in a single book. If the literate command line tool is run on
a single file, it should compile that file, if it is run on a directory,
it should search for the <code>Summary.lit</code> file in the directory and create a
book.
</p>
<p>What should the directory structure of a Literate book look like?
I try to mimic the <a href="https://github.com/GitbookIO/gitbook">Gitbook</a> software
here. There will be a <code>Summary.lit</code> file which links to each of the
different chapters in the book. An example <code>Summary.lit</code> file might look
like this:
</p>
<pre><code>@title Title of the book

[Chapter 1](chapter1/intro.lit)
    [Subchapter 1](chapter1/example1.lit)
    [Subchapter 2](chapter1/example2.lit)
[Chapter 2](section2/intro.lit)
    [Subchapter 1](chapter2/example1.lit)
</code></pre><p>Sub chapters are denoted by tabs, and each chapter is linked to the correct
<code>.lit</code> file using Markdown link syntax.
</p>

</div>
<a name="1:3"><div class="section"><h4>3. The Parser</h4></a>
<p>As a first step, I'll make a parser for single chapters only, and leave having
multiple chapters and books for later.
</p>
<p>The parser will have 2 main parts to it: the which represent the various structures
in a literate program, and the parse function.
</p>

<div class="codeblock">
<span class="codeblock_name">{<strong>parser.d</strong> <a href="parser.html#1:3">3</a>}</span>
<pre class="prettyprint lang-d">
<span class="nocode pln">{Imports, <a href="parser.html#1:3">3</a>}</span>
<span class="nocode pln">{Classes, <a href="parser.html#1:4">4</a>}</span>
<span class="nocode pln">{Parse functions, <a href="parser.html#1:12">12</a>}</span>
</pre>



</div>
<p>I'll quickly list the imports here.
</p>

<div class="codeblock">
<span class="codeblock_name">{Imports <a href="parser.html#1:3">3</a>}</span>
<pre class="prettyprint lang-d">
import globals;
import std.stdio;
import util;
import std.string: split, endsWith, startsWith, chomp, replace, strip;
import std.algorithm: canFind;
import std.regex: matchAll, matchFirst, regex, ctRegex, splitter;
import std.conv;
import std.path: extension;
import std.file;
</pre>



</div>
</div>
<a name="1:4"><div class="section"><h4 class="noheading">4. </h4></a>
<p>Now we have to define the classes used to represent a literate program. There
are 7 such classes:
</p>

<div class="codeblock">
<span class="codeblock_name">{Classes <a href="parser.html#1:4">4</a>}</span>
<pre class="prettyprint lang-d">
<span class="nocode pln">{Line class, <a href="parser.html#1:10">10</a>}</span>
<span class="nocode pln">{Command class, <a href="parser.html#1:9">9</a>}</span>
<span class="nocode pln">{Block class, <a href="parser.html#1:8">8</a>}</span>
<span class="nocode pln">{Section class, <a href="parser.html#1:7">7</a>}</span>
<span class="nocode pln">{Chapter class, <a href="parser.html#1:6">6</a>}</span>
<span class="nocode pln">{Program class, <a href="parser.html#1:5">5</a>}</span>
<span class="nocode pln">{Change class, <a href="parser.html#1:11">11</a>}</span>
</pre>


<p class="seealso">Used in section <a href="parser.html#1:3">3</a></p>
</div>
</div>
<a name="1:5"><div class="section"><h4>5. The Program Class</h4></a>
<p>What is a literate program at the highest level? A program has multiple chapters,
it has a title, and it has various commands associated with it (although some of these
commands may be overwritten by chapters or even sections). It also has the file it
originally came from.
</p>

<div class="codeblock">
<span class="codeblock_name">{Program class <a href="parser.html#1:5">5</a>}</span>
<pre class="prettyprint lang-d">
class Program {
    public string title;
    public Command[] commands;
    public Chapter[] chapters;
    public string file;
    public string text;

    this() {
        commands = [];
        chapters = [];
    }
}
</pre>


<p class="seealso">Used in section <a href="parser.html#1:4">4</a></p>
</div>
</div>
<a name="1:6"><div class="section"><h4>6. The Chapter class</h4></a>
<p>A chapter is very similar to a program. It has a title, commands, sections, and also
an original file. In the case of a single file program (which is what we are focusing
on for the moment) the Program's file and the Chapter's file will be the same. A chapter
also has a minor number and a major number;
</p>

<div class="codeblock">
<span class="codeblock_name">{Chapter class <a href="parser.html#1:6">6</a>}</span>
<pre class="prettyprint lang-d">
class Chapter {
    public string title;
    public Command[] commands;
    public Section[] sections;
    public string file;

    public int majorNum;
    public int minorNum;

    this() {
        commands = [];
        sections = [];
    }

    string num() {
        if (minorNum != 0) {
            return to!string(majorNum) ~ "." ~ to!string(minorNum);
        } else {
            return to!string(majorNum);
        }
    }
}
</pre>


<p class="seealso">Used in section <a href="parser.html#1:4">4</a></p>
</div>
</div>
<a name="1:7"><div class="section"><h4>7. The Sections class</h4></a>
<p>A section has a title, commands, a number, and a series of blocks, which can either be
blocks of code, or blocks of prose.
</p>

<div class="codeblock">
<span class="codeblock_name">{Section class <a href="parser.html#1:7">7</a>}</span>
<pre class="prettyprint lang-d">
class Section {
    public string title;
    public Command[] commands;
    public Block[] blocks;
    public int num;

    this() {
        commands = [];
        blocks = [];
    }
}
</pre>


<p class="seealso">Used in section <a href="parser.html#1:4">4</a></p>
</div>
</div>
<a name="1:8"><div class="section"><h4>8. The Block Class</h4></a>
<p>A block is more interesting. It can either be a block of code, or a block of prose, so
it has a boolean which represents what type it is. It also stores a start line. If it
is a code block, it also has a name. Finally, it stores an array of lines, and has a function
called <code>text()</code> which just returns the string of the text it contains. A block also contains
a <code>codeType</code> and a <code>commentString</code>.
</p>

<div class="codeblock">
<span class="codeblock_name">{Block class <a href="parser.html#1:8">8</a>}</span>
<pre class="prettyprint lang-d">
class Block {
    public int startLine;
    public string name;
    public bool isCodeblock;
    public bool isRootBlock;
    public Line[] lines;

    public string codeType;
    public string commentString;

    public Modifier[] modifiers;

    this() {
        lines = [];
        modifiers = [];
    }

    string text() {
        string text = "";
        foreach (line; lines) {
            text ~= line.text ~ "\n";
        }
        return text;
    }

    Block dup() {
        Block b = new Block();
        b.startLine = startLine;
        b.name = name;
        b.isCodeblock = isCodeblock;
        b.codeType = codeType;
        b.commentString = commentString;
        b.modifiers = modifiers;

        foreach (Line l; lines) {
            b.lines ~= l.dup();
        }

        return b;
    }
}
</pre>


<p class="seealso">Used in section <a href="parser.html#1:4">4</a></p>
</div>
</div>
<a name="1:9"><div class="section"><h4>9. The Command Class</h4></a>
<p>A command is quite simple. It has a name, and any arguments that are passed.
</p>

<div class="codeblock">
<span class="codeblock_name">{Command class <a href="parser.html#1:9">9</a>}</span>
<pre class="prettyprint lang-d">
class Command {
    public string name;
    public string args;
    public int lineNum;
    public string filename;
    this() {}
}
</pre>


<p class="seealso">Used in section <a href="parser.html#1:4">4</a></p>
</div>
</div>
<a name="1:10"><div class="section"><h4>10. The Line Class</h4></a>
<p>A line is the lowest level. It stores the line number, the file the line is from, and the
text for the line itself.
</p>

<div class="codeblock">
<span class="codeblock_name">{Line class <a href="parser.html#1:10">10</a>}</span>
<pre class="prettyprint lang-d">
class Line {
    public string file;
    public int lineNum;
    public string text;

    this(string text, string file, int lineNum) {
        this.text = text;
        this.file = file;
        this.lineNum = lineNum;
    }

    Line dup() {
        return new Line(text, file, lineNum);
    }
}
</pre>


<p class="seealso">Used in section <a href="parser.html#1:4">4</a></p>
</div>
</div>
<a name="1:11"><div class="section"><h4>11. The Change Class</h4></a>
<p>The change class helps when parsing a change statement. It stores the file that is being changed,
what the text to search for is and what the text to replace it with is. These two things are arrays
because you can make multiple changes (search and replaces) to one file. In order to
keep track of the current change, an index is also stored.
</p>

<div class="codeblock">
<span class="codeblock_name">{Change class <a href="parser.html#1:11">11</a>}</span>
<pre class="prettyprint lang-d">
class Change {
    public string filename;
    public string[] searchText;
    public string[] replaceText;
    public int index;

    this() {
        searchText = [];
        replaceText = [];
        index = 0;
    }
}
</pre>


<p class="seealso">Used in section <a href="parser.html#1:4">4</a></p>
</div>
<p>That's it for the classes. These 7 classes can be used to represent an entire literate program.
Now let's get to the actual parse function to turn a text file into a program.
</p>

</div>
<a name="1:12"><div class="section"><h4>12. The Parse Function</h4></a>
<p>Here we have two functions: <code>parseProgram</code> and <code>parseChapter</code>.
</p>

<div class="codeblock">
<span class="codeblock_name">{Parse functions <a href="parser.html#1:12">12</a>}</span>
<pre class="prettyprint lang-d">
<span class="nocode pln">{parseProgram function, <a href="parser.html#1:13">13</a>}</span>
<span class="nocode pln">{parseChapter function, <a href="parser.html#1:14">14</a>}</span>
</pre>


<p class="seealso">Used in section <a href="parser.html#1:3">3</a></p>
</div>
</div>
<a name="1:13"><div class="section"><h4>13. parseProgram function</h4></a>
<p>This function takes a literate book source and parses each chapter and returns the final program.
</p>
<p>Here is an example book:
</p>
<pre><code>@title Title of the book
</code></pre><pre><code>[Chapter 1](chapter1/intro.lit)
    [Subchapter 1](chapter1/example1.lit)
    [Subchapter 2](chapter1/example2.lit)
[Chapter 2](section2/intro.lit)
    [Subchapter 1](chapter2/example1.lit)
</code></pre>
<div class="codeblock">
<span class="codeblock_name">{parseProgram function <a href="parser.html#1:13">13</a>}</span>
<pre class="prettyprint lang-d">
Program parseProgram(Program p, string src) {
    string filename = p.file;
    bool hasChapters;

    string[] lines = src.split("\n");
    int lineNum;
    int majorNum;
    int minorNum;
    foreach (line; lines) {
        lineNum++;

        if (line.startsWith("@title")) {
            p.title = strip(line[6..$]);
        } else if (line.startsWith("@book")) {
            continue;
        } else if (auto matches = matchFirst(line, regex(r"\[(?P&lt;chapterName&gt;.*)\]\((?P&lt;filepath&gt;.*)\)"))) {
            if (matches["filepath"] == "") {
                error(filename, lineNum, "No filepath for " ~ matches["chapterName"]);
                continue;
            }
            if (leadingWS(line).length &gt; 0) {
                minorNum++;
            } else {
                majorNum++;
                minorNum = 0;
            }
            Chapter c = new Chapter();
            c.file = matches["filepath"];
            c.title = matches["chapterName"];
            c.majorNum = majorNum;
            c.minorNum = minorNum;

            p.chapters ~= parseChapter(c, readall(File(matches["filepath"])));
            hasChapters = true;
        } else {
            p.text ~= line ~ "\n";
        }
    }

    return p;
}
</pre>


<p class="seealso">Used in section <a href="parser.html#1:12">12</a></p>
</div>
</div>
<a name="1:14"><div class="section"><h4>14. parseChapter function</h4></a>
<p>The <code>parseChapter</code> function is the more complex one. It parses the source of a chapter.
Before doing any parsing, we resolve the <code>@include</code> statements by replacing them with
the contents of the file that was included. Then we loop through each line in the source
and parse it, provided that it is not a comment (starting with <code>//</code>);
</p>

<div class="codeblock">
<span class="codeblock_name">{parseChapter function <a href="parser.html#1:14">14</a>}</span>
<pre class="prettyprint lang-d">
Chapter parseChapter(Chapter chapter, string src) {
<span class="nocode pln">    {Initialize some variables, <a href="parser.html#1:15">15</a>}</span>

    string[] blocks = [];

    string include(string file) {
        if (file == filename) {
            error(filename, 1, "Recursive include");
            return "";
        }
        if (!exists(file)){
            error(filename, 1, "File " ~ file ~ " does not exist");
            return "";
        }
        return readall(File(file));
    }

    // Handle the @include statements
    src = std.regex.replaceAll!(match =&gt; include(match[1]))(src, regex(`\n@include (.*)`));
    string[] lines = src.split("\n");

    int lineNum = 0;
    foreach (line; lines) {
        lineNum++;

        if (strip(line).startsWith("//") &amp;&amp; !inCodeblock) {
            continue;
        }

<span class="nocode pln">        {Parse the line, <a href="parser.html#1:16">16</a>}</span>
    }
<span class="nocode pln">    {Close the last section, <a href="parser.html#1:22">22</a>}</span>

    return chapter;
}
</pre>


<p class="seealso">Used in section <a href="parser.html#1:12">12</a></p>
</div>
</div>
<a name="1:15"><div class="section"><h4>15. The Parse Function Setup</h4></a>
<p>For the initial variables, it would be nice to move the value for <code>chapter.file</code> into a variable
called <code>filename</code>. Additionally, I'm going to need an array of all the possible commands that
are recognized.
</p>

<div class="codeblock">
<span class="codeblock_name">{Initialize some variables <a href="parser.html#1:15">15</a>}</span>
<pre class="prettyprint lang-d">
string filename = chapter.file;
string[] commands = ["@code_type", "@comment_type", "@compiler", "@error_format", 
                     "@add_css", "@overwrite_css", "@colorscheme", "@include"];
</pre>
<p class="seealso">Added to in section <a href="parser.html#1:15">15</a></p>

<p class="seealso">Used in section <a href="parser.html#1:14">14</a></p>
</div>
<p>I also need to keep track of the current section that is being parsed, and the current block that
is being parsed, because the parser is going through the file one line at a time. I'll also define
the current change being parsed.
</p>

<div class="codeblock">
<span class="codeblock_name">{Initialize some variables <a href="parser.html#1:15">15</a>} +=</span>
<pre class="prettyprint lang-d">
Section curSection;
int sectionNum = 0;
Block curBlock;
Change curChange;
</pre>
<p class="seealso">Added to in section <a href="parser.html#1:15">15</a></p>

<p class="seealso">Used in section <a href="parser.html#1:14">14</a></p>
</div>
<p>Finally, I need 3 flags to keep track of if it is currently parsing a codeblock, a search block,
or a replace block.
</p>

<div class="codeblock">
<span class="codeblock_name">{Initialize some variables <a href="parser.html#1:15">15</a>} +=</span>
<pre class="prettyprint lang-d">
bool inCodeblock = false;
bool inSearchBlock = false;
bool inReplaceBlock = false;
</pre>
<p class="seealso">Added to in section <a href="parser.html#1:15">15</a></p>

<p class="seealso">Used in section <a href="parser.html#1:14">14</a></p>
</div>
</div>
<a name="1:16"><div class="section"><h4>16. Parsing the Line</h4></a>
<p>When parsing a line, we are either inside a code block, or inside a prose block, or we are transitioning
from one to the other. So we'll have an if statement to separate the two.
</p>

<div class="codeblock">
<span class="codeblock_name">{Parse the line <a href="parser.html#1:16">16</a>}</span>
<pre class="prettyprint lang-d">
if (!inCodeblock) {
    // This might be a change block
<span class="nocode pln">    {Parse change block, <a href="parser.html#1:23">23</a>}</span>
<span class="nocode pln">    {Parse a command, <a href="parser.html#1:16">16</a>}</span>
<span class="nocode pln">    {Parse a title command, <a href="parser.html#1:16">16</a>}</span>
<span class="nocode pln">    {Parse a section definition, <a href="parser.html#1:17">17</a>}</span>
<span class="nocode pln">    {Parse the beginning of a code block, <a href="parser.html#1:18">18</a>}</span>
    else if (curBlock !is null) {
        if (line.split().length &gt; 1) {
            if (commands.canFind(line.split()[0])) {
                continue;
            }
        }
<span class="nocode pln">        {Add the line to the list of lines, <a href="parser.html#1:21">21</a>}</span>
    }
} else if (startsWith(line, "---")) {
<span class="nocode pln">    {Begin a new prose block, <a href="parser.html#1:20">20</a>}</span>
} else if (curBlock !is null) {
<span class="nocode pln">    {Add the line to the list of lines, <a href="parser.html#1:21">21</a>}</span>
}
</pre>


<p class="seealso">Used in section <a href="parser.html#1:14">14</a></p>
</div>
<p>Parsing a command and the title command are both fairly simple, so let's look at them first.
</p>
<p>To parse a command we first make sure that there is the command name, and any arguments.
Then we check if the command is part of the list of commands we have. If it is, we
create a new command object, fill in the name and arguments, and add it to the chapter object.
</p>
<p>We also do something special if it is a <code>@include</code> command. For these ones, we take the file
read it, and parse it as a chapter (using the <code>parseChapter</code> function). Then we add the
included chapter's sections to the current chapter's sections. In this case, we don't add
the <code>@include</code> command to the list of chapter commands.
</p>

<div class="codeblock">
<span class="codeblock_name">{Parse a command <a href="parser.html#1:16">16</a>}</span>
<pre class="prettyprint lang-d">
if (line.split().length &gt; 1) {
    if (commands.canFind(line.split()[0])) {
        Command cmd = new Command();
        cmd.name = line.split()[0];
        auto index = cmd.name.length;
        cmd.args = strip(line[index..$]);
        cmd.lineNum = lineNum;
        cmd.filename = filename;
        if (cmd.args == "none") {
            cmd.args = "";
        }

        if (curSection is null) {
            chapter.commands ~= cmd;
        } else {
            curSection.commands ~= cmd;
        }
    }
}
</pre>



</div>
<p>Parsing an <code>@title</code> command is even simpler.
</p>

<div class="codeblock">
<span class="codeblock_name">{Parse a title command <a href="parser.html#1:16">16</a>}</span>
<pre class="prettyprint lang-d">
if (startsWith(line, "@title")) {
    chapter.title = strip(line[6..$]);
}
</pre>



</div>
</div>
<a name="1:17"><div class="section"><h4>17. Parsing a Section Definition</h4></a>
<p>When a new section is created (using <code>@s</code>), we should add the current section to the list
of sections for the chapter, and then we should create a new section, which becomes the
current section.
</p>

<div class="codeblock">
<span class="codeblock_name">{Parse a section definition <a href="parser.html#1:17">17</a>}</span>
<pre class="prettyprint lang-d">
else if (startsWith(line, "@s")) {
    if (curBlock !is null &amp;&amp; !curBlock.isCodeblock) {
        if (strip(curBlock.text()) != "") {
            curSection.blocks ~= curBlock;
        }
    } else if (curBlock !is null &amp;&amp; curBlock.isCodeblock) {
        error(chapter.file, curBlock.startLine, "Unclosed block {" ~ curBlock.name ~ "}");
    }
    // Make sure the section exists
    if (curSection !is null) {
        chapter.sections ~= curSection;
    }
    curSection = new Section();
    curSection.title = strip(line[2..$]);
    curSection.commands = chapter.commands ~ curSection.commands;
    curSection.num = ++sectionNum;

    curBlock = new Block();
    curBlock.isCodeblock = false;
}
</pre>


<p class="seealso">Used in section <a href="parser.html#1:16">16</a></p>
</div>
</div>
<a name="1:18"><div class="section"><h4>18. Parse the Start of a Codeblock</h4></a>
<p>Codeblocks always begin with <code>--- title</code>, so we can use the regex <code>^---.+</code> to represent this.
Once a new codeblock starts, the old one must be appended to the current section's list of
blocks, and the current codeblock must be reset.
</p>

<div class="codeblock">
<span class="codeblock_name">{Parse the beginning of a code block <a href="parser.html#1:18">18</a>}</span>
<pre class="prettyprint lang-d">
else if (matchAll(line, regex("^---.+"))) {
    if (curSection is null) {
        error(chapter.file, lineNum, "You must define a section with @s before writing a code block");
        continue;
    }

    if (curBlock !is null) {
        curSection.blocks ~= curBlock;
    }
    curBlock = new Block();
    curBlock.startLine = lineNum;
    curBlock.isCodeblock = true;
    curBlock.name = strip(line[3..$]);

<span class="nocode pln">    {Parse Modifiers, <a href="parser.html#1:19">19</a>}</span>

    if (blocks.canFind(curBlock.name)) {
        if (!curBlock.modifiers.canFind(Modifier.redef) &amp;&amp; !curBlock.modifiers.canFind(Modifier.additive)) {
            error(filename, lineNum, "Redefinition of {" ~ curBlock.name ~ "}, use ':=' to redefine");
        }
    } else {
        blocks ~= curBlock.name;
    }

    foreach (cmd; curSection.commands) {
        if (cmd.name == "@code_type") {
            curBlock.codeType = cmd.args;
        } else if (cmd.name == "@comment_type") {
            curBlock.commentString = cmd.args;
        }
    }

    inCodeblock = true;
}
</pre>


<p class="seealso">Used in section <a href="parser.html#1:16">16</a></p>
</div>
</div>
<a name="1:19"><div class="section"><h4>19. Check for and extract modifiers.</h4></a>
<p>Modifier format for a code block: <code>--- Block Name --- noWeave +=</code>.
The <code>checkForModifiers</code> ugliness is due to lack of <code>(?|...)</code> and friends.
</p>
<p>First half matches for expressions <em>with</em> modifiers:
</p>
<ol>
<li><code>(?P&lt;namea&gt;\S.*)</code> : Keep taking from the first non-whitespace character ...
</li>
<li><code>[ \t]-{3}[ \t]</code> : Until it matches <code> --- </code>
</li>
<li><code>(?P&lt;modifiers&gt;.+)</code> : Matches everything after the separator.
</li>
</ol>
<p>Second half matches for no modifiers: Ether <code>Block name</code> and with a floating separator <code>Block Name ---</code>.
</p>
<ol>
<li><code>|(?P&lt;nameb&gt;\S.*?)</code> : Same thing as #1 but stores it in <code>nameb</code>
</li>
<li><code>[ \t]*?</code> : Checks for any amount of whitespace (Including none.)
</li>
<li><code>(-{1,}$</code> : Checks for any floating <code>-</code> and verifies that nothing else is there untill end of line.
</li>
<li><code>|$))</code> : Or just checks that there is nothing but the end of the line after the whitespace.
</li>
</ol>
<p>Returns ether <code>namea</code> and <code>modifiers</code> or just <code>nameb</code>. 
</p>

<div class="codeblock">
<span class="codeblock_name">{Parse Modifiers <a href="parser.html#1:19">19</a>}</span>
<pre class="prettyprint lang-d">
auto checkForModifiers = ctRegex!(`(?P&lt;namea&gt;\S.*)[ \t]-{3}[ \t](?P&lt;modifiers&gt;.+)|(?P&lt;nameb&gt;\S.*?)[ \t]*?(-{1,}$|$)`);
auto splitOnSpace = ctRegex!(r"(\s+)");
auto modMatch = matchFirst(curBlock.name, checkForModifiers);

// matchFirst returns unmatched groups as empty strings

if (modMatch["namea"] != "") {
    curBlock.name = modMatch["namea"];
} else if (modMatch["nameb"] != ""){
    curBlock.name = modMatch["nameb"];
    // Check for old syntax.
    if (curBlock.name.endsWith("+=")) {
        curBlock.modifiers ~= Modifier.additive;
        curBlock.name = strip(curBlock.name[0..$-2]);
    } else if (curBlock.name.endsWith(":=")) {
        curBlock.modifiers ~= Modifier.redef;
        curBlock.name = strip(curBlock.name[0..$-2]);
    }
} else {
    error(filename, lineNum, "Something went wrong with: " ~ curBlock.name);
}

if (modMatch["modifiers"]) {
    foreach (m; splitter(modMatch["modifiers"], splitOnSpace)) {
        switch(m) {
            case "+=":
                curBlock.modifiers ~= Modifier.additive;
                break;
            case ":=":
                curBlock.modifiers ~= Modifier.redef;
                break;
            case "noWeave":
                curBlock.modifiers ~= Modifier.noWeave;
                break;
            case "noTangle":
                curBlock.modifiers ~= Modifier.noTangle;
                break;
            default:
                error(filename, lineNum, "Invalid modifier: " ~ m);
                break;
        }
    }

}
</pre>


<p class="seealso">Used in section <a href="parser.html#1:18">18</a></p>
</div>
</div>
<a name="1:20"><div class="section"><h4>20. Parse the End of a Codeblock</h4></a>
<p>Codeblocks end with just a <code>---</code>. When a codeblock ends, we do the same as when it begins,
except the new block we create is a block of prose as opposed to code.
</p>

<div class="codeblock">
<span class="codeblock_name">{Begin a new prose block <a href="parser.html#1:20">20</a>}</span>
<pre class="prettyprint lang-d">
if (curBlock !is null) {
    curSection.blocks ~= curBlock;
}
curBlock = new Block();
curBlock.startLine = lineNum;
curBlock.isCodeblock = false;
inCodeblock = false;
</pre>


<p class="seealso">Used in section <a href="parser.html#1:16">16</a></p>
</div>
</div>
<a name="1:21"><div class="section"><h4>21. Add the current line</h4></a>
<p>Finally, if the current line is nothing interesting, we just add it to the current block's
list of lines.
</p>

<div class="codeblock">
<span class="codeblock_name">{Add the line to the list of lines <a href="parser.html#1:21">21</a>}</span>
<pre class="prettyprint lang-d">
curBlock.lines ~= new Line(line, filename, lineNum);
</pre>


<p class="seealso">Used in sections <a href="parser.html#1:16">16</a> and <a href="parser.html#1:16">16</a></p>
</div>
<p>Now we're done parsing the line.
</p>

</div>
<a name="1:22"><div class="section"><h4>22. Closing the last section</h4></a>
<p>When the end of the file is reached, the last section has not been closed and added to the
chapter yet, so we should do that. Additionally, if the last block is a prose block, it should
be closed and added to the section first. If the last block is a code block, it should have been
closed with <code>---</code>. If it wasn't we'll throw an error.
</p>

<div class="codeblock">
<span class="codeblock_name">{Close the last section <a href="parser.html#1:22">22</a>}</span>
<pre class="prettyprint lang-d">
if (curBlock !is null) {
    if (!curBlock.isCodeblock) {
        curSection.blocks ~= curBlock;
    } else {
        writeln(filename, ":", lineNum - 1, ":error: {", curBlock.name, "} is never closed");
    }
}
if (curSection !is null) {
    chapter.sections ~= curSection;
}
</pre>


<p class="seealso">Used in section <a href="parser.html#1:14">14</a></p>
</div>
</div>
<a name="1:23"><div class="section"><h4>23. Parsing the change block</h4></a>
<p>Parsing a change block is somewhat complex. Change blocks look like this:
</p>
<pre><code>@change file.lit

Some comments here...

@replace
replace this text
@with
with this text
@end

More comments ...

@replace
...
@with
...
@end

...

@change_end
</code></pre><p>You can make multiple changes on one file. We've got two nice flags for keeping track of
which kind of block we are in: replaceText or searchText.
</p>

<div class="codeblock">
<span class="codeblock_name">{Parse change block <a href="parser.html#1:23">23</a>}</span>
<pre class="prettyprint lang-d">
// Start a change block
if (startsWith(line, "@change") &amp;&amp; !startsWith(line, "@change_end")) {
    curChange = new Change();
    curChange.filename = strip(line[7..$]);
    continue;
} else if (startsWith(line, "@replace")) {
    // Begin the search block
    curChange.searchText ~= "";
    curChange.replaceText ~= "";
    inReplaceBlock = false;
    inSearchBlock = true;
    continue;
} else if (startsWith(line, "@with")) {
    // Begin the replace block and end the search block
    inReplaceBlock = true;
    inSearchBlock = false;
    continue;
} else if (startsWith(line, "@end")) {
    // End the replace block
    inReplaceBlock = false;
    inSearchBlock = false;
    // Increment the number of changes
    curChange.index++;
    continue;
} else if (startsWith(line, "@change_end")) {
    // Apply all the changes
    string text = readall(File(curChange.filename));
    foreach (i; 0 .. curChange.index) {
        text = text.replace(curChange.searchText[i], curChange.replaceText[i]);
    }
    Chapter c = new Chapter();
    c.file = curChange.filename;
    // We can ignore these, but they need to be initialized
    c.title = "";
    c.majorNum = -1;
    c.minorNum = -1;
    Chapter includedChapter = parseChapter(c, text);
    // Overwrite the current file's title and add to the commands and sections
    chapter.sections ~= includedChapter.sections;
    chapter.commands ~= includedChapter.commands;
    chapter.title = includedChapter.title;
    continue;
}

// Just add the line to the search or replace text depending
else if (inSearchBlock) {
    curChange.searchText[curChange.index] ~= line ~ "\n";
    continue;
} else if (inReplaceBlock) {
    curChange.replaceText[curChange.index] ~= line ~ "\n";
    continue;
}
</pre>


<p class="seealso">Used in section <a href="parser.html#1:16">16</a></p>
</div>

</div>
</body>
